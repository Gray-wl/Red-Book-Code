JavaScript变量是松散类型

**原始值与引用值**

**原始值**（primitive value）就是最简单的数据，**引用值**（reference value）则是由多个值构成的对象	

保存原始值的变量是按值（by value）访问的

保存引用值的变量是按引用（by reference）访问的

- 动态属性

- 复制值

- 传递参数

  > ECMAScript中函数的参数就是局部变量

- 确定类型

  - `typeof`操作符判断原始类型
  - `instanceof`操作符判断引用类型



**执行上下文与作用域**

变量或函数的上下文决定了它们可以访问哪些数据，以及它们的行为

上下文中的代码在执行的时候，会创建变量对象的一个**作用域链**（scope chain），决定了各级上下文中的代码在访问变量和函数时的顺序

- 作用域链增强
  - try/catch语句的catch块
  - with语句
- 变量声明
  - 严格来讲，let在JavaScript运行时中也会被提升，但由于“**暂时性死区**”（temporal dead zone）的缘故，实际上不能在声明之前使用let变量。因此，从写JavaScript代码的角度说，let的提升跟var是不一样的
  - **Object.freeze()** 让整个对象都不能修改，虽然不会报错，但会静默失败



**垃圾回收**

确定哪个变量不会再使用，然后释放它占用的内存

- 标记清理
- 引用计数： 问题：循环引用，非原生JavaScript对象



**性能**

- 内存管理
  - 如果数据不再必要，那么把它设置为null，从而释放其引用， 适合全局变量和全局对象的属性
  - 通过const和let声明提升性能
  - 隐藏类和删除操作
  - 内存泄漏
  - 静态分配与对象池